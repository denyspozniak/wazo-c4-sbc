#!KAMAILIO

# Defined Values
# ==============

# #!define WITH_DEBUG 1
#!define WITH_ANTIFLOOD 1
#!define WITH_AUTH 1

#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

#!define SCANNER_BLACKLIST "sipsak|friendly-scanner|sipvicious|sipcli|sip-scan|sundayddr|iWar|CSipSimple|SIVuS|Gulp|sipv|smap|friendly-request|VaxIPUserAgent|VaxSIPUserAgent|siparmyknife|Test Agent"

# Global Parameters
# =================
children=8

log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

memdbg=5
memlog=5

# LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
sip_warning=1
#!else
debug=2
log_stderror=no
sip_warning=0
#!endif

####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

listen=LISTEN

# Modules Section
# ===============
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "dialog.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "sdpops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "htable.so"
loadmodule "http_async_client.so"
loadmodule "rtjson.so"
loadmodule "jansson.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"
#!ifdef WITH_AUTH
loadmodule "auth.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

#!ifdef WITH_DEBUGGER
loadmodule "debugger.so"
#!endif


# Setting module-specific parameters
# ==================================

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "reparse_on_dns_failover", 0)
modparam("tm", "cancel_b_method", 0)

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)
# ----- pike/htable params -----
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_DEBUGGER
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")
#!endif

# ----- rr params -----
# add value to ;lr param to cope with most of the UAs
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)
modparam("rr", "enable_double_rr", 1)

# ----- http_async_client params -----
modparam("http_async_client", "workers", 4)
modparam("http_async_client", "connection_timeout", 2000)

# ----- pv params -----
# enable or disable pike
modparam("pv", "shvset", "pike_off=i:0")

#!ifdef WITH_AUTH
# ----- auth params -----
#!ifdef ROUTER_AUTH_SECRET
modparam("auth", "secret", ROUTER_AUTH_SECRET)
modparam("auth", "algorithm", "MD5")
# ----- auth/htable params -----
modparam("htable", "htable", "auth=>size=16;autoexpire=60;")
#!endif
#!endif

# ----- rtpengine params -----
modparam("rtpengine", "rtpengine_sock", RTPENGINE_LIST)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
# modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@wazo.io")
modparam("nathelper", "keepalive_timeout", 120)
modparam("nathelper", "sipping_method", "OPTIONS")

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("nathelper", "udpping_from_path", 1)

# Routing Logic
# =============
request_route {
    # per request initial checks
    route(REQINIT);
    # NAT detection
    route(NATDETECT);
    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RTPE);
            route(RELAY);
        }
        exit;
    }
    # handle retransmissions
    if (!is_method("ACK")) {
        if (t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }
    # handle requests within SIP dialogs
    route(WITHINDLG);
    # ----- only initial requests (no To tag) -----
    # record routing for dialog forming requests (in case they are routed)
    # - remove preloaded route headers
    remove_hf("Route");
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }
    # account only INVITEs
    if (is_method("INVITE")) {
        setflag(FLT_ACC); # do accounting
    }
    # enable dialog management
    if (is_method("INVITE")) {
      dlg_manage();
    }
    # relay the messages
    route(RELAY_API);
}


# Per SIP request initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
    if ($shv(pike_off) == 0) {
        if (src_ip!=myself) {
            if ($sht(ipban=>$si)!=$null) {
                # ip is already blocked
                xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
                exit;
            }
            if (!pike_check_req()) {
                xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
                $sht(ipban=>$si) = 1;
                exit;
            }
        }
    }
    else if ($shv(pike_off) == 1) {
        xlog("L_NOTICE","PIKE: forced to OFF!\n");
    }
#!endif
    if ($ua =~ SCANNER_BLACKLIST) {
        # silent drop for scanners - uncomment next line if want to reply
        # sl_send_reply("200", "OK");
        exit;
    }
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }
    if (is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        exit;
    }
    if (!sanity_check("17895", "7")) {
        xlog("Malformed SIP message from $si:$sp\n");
        exit;
    }
}


# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;
    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        if (is_method("INVITE|UPDATE") && sdp_content() && nat_uac_test("18")) {
            route(RTPE);
        }
        if (is_method("BYE")) {
            setflag(FLT_ACC); # do accounting ...
            setflag(FLT_ACCFAILED); # ... even if the transaction fails
        } else if ( is_method("ACK") ) {
            # ACK is forwarded statelessly
            route(RTPE);
            route(NATMANAGE);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
        exit;
    }
    if (is_method("ACK")) {
        if (t_check_trans()) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            exit;
        }
    }
    sl_send_reply("404","Not here");
    exit;
}


# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if (is_first_hop())
                set_contact_alias();
        }
        setflag(FLT_NATS);
    }
#!endif
    return;
}


# NAT management control
route[NATMANAGE] {
#!ifdef WITH_NAT
    if (is_request()) {
        if (has_totag()) {
            if (check_route_param("nat=yes")) {
                setbflag(FLB_NATB);
            }
        }
    }
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB)))
        return;

    if (is_request()) {
        if (!has_totag()) {
            if (t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    if (is_reply()) {
        if (isbflagset(FLB_NATB)) {
            set_contact_alias();
        }
    }
#!endif
    return;
}


# Wrapper for relaying requests
route[RELAY] {
    # enable additional event routes for forwarded requests
    # - serial forking, RTP relaying handling, a.s.o.
    if (is_method("INVITE|BYE|UPDATE|CANCEL|ACK")) {
        dlg_manage();
    }
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if (!t_is_set("branch_route")) {
            t_on_branch("MANAGE_BRANCH");
        }
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if (!t_is_set("onreply_route")) {
            t_on_reply("MANAGE_REPLY");
        }
    }
    if (is_method("INVITE")) {
        if (!t_is_set("failure_route")) {
            t_on_failure("MANAGE_FAILURE");
        }
    }
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}


# Manages RTP Engine
route[RTPE] {
    if (!is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) return;

    if (is_method("ACK") && !has_body("application/sdp")) return;

    $var(common_opts) = 'replace-session-connection replace-origin';

    if (nat_uac_test("18")) {
        xlog("L_INFO", "-- RTPENGINE: NAT detected, do not trust SDP addresses\n");
        $var(symmetry) = 'SIP-source-address';
    } else {
        xlog("L_INFO", "-- RTPENGINE: No NAT detected, trust SDP addresses\n");
        $var(symmetry) = 'trust-address';
    }

    $var(wsopts) ='ICE=remove RTP/AVP';
    $var(interfaces) = "direction=external direction=external";

    if (sdp_content()){
        xlog("L_INFO", "-- RTPENGINE: rtpengine_manage [$var(common_opts) $var(symmetry) $var(wsopts) $var(interfaces)]\n");
        if (is_method("INVITE")) {
            rtpengine_offer("$var(common_opts) $var(symmetry) $var(wsopts) $var(interfaces)");
        } else {
            rtpengine_manage("$var(common_opts) $var(symmetry) $var(wsopts) $var(interfaces)");
        }
    }
}


# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    # rtjson_update_branch();
    route(RTPE);
}


# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xdbg("incoming reply\n");
    route(RTPE);
}


# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
    if (t_is_canceled()) {
        exit;
    }
    if (rtjson_next_route()) {
        route(RELAY);
        exit;
    }
}
